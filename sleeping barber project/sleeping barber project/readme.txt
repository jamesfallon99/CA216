This program was initally designed to work with one barber and a waiting room with a limited number of seats(60% version). I decided to add more theads to act as more barbers(100% version).
If the 100% version isn't correct, all you have to do is remove 2 of the threads and that should leave you with the 60% version.

I first tested this code by creating a single threaded program. I didn't use any threads, locks or events at this stage of development. I wanted to see if I could imitate a waiting room with a number of customers already in it and get the work() and hair_cut() functions working.
When I successfully had these functions working, I then created  the customer_enters_barbers() function. I tested to make sure that a customer could be taken in from a list of arriving customers and passed through this function. Before I created the num_seats_in_waiting_room variable, I used an integer in my function just to make sure the function behaved the way I wanted it to. If there was enough seats, the customer would take a seat, otherwise they would leave.
I got these 3 functions of the program working but they didn't occur concurrently, they all happened seperately. Initally the program dealt with all the customers coming into the shop. As the haircut function wasn't being called, the customers would have no where to sit so they had to leave. Once the program was finished with all the arriving customers, it moved on to all the people in the waiting room and proceeded to cut their hair.
I then created a thread on the work() function to test if I could get the program working concurrently and behave more like the way I intended it to. This started to shape the program into the way I wanted, but then I noticed that as the work() function evaluates the amount of people in the waiting room, a customer could walk in, but before he gets appended to the waiting room, it will already have evaluated the amount of people in the waiting room to 0 and therefore the customer's hair won't be cut until someone else walks in. I came to realise that locks would have to be used. Locks are used to prevent other functions from accessing shared data. In this case, the work() and customer_enters_barbers() functions both share the waiting room. This prevented the above problem from occuring.
I then started to implement events into the program. This is one of the simplest mechanisms for communication between threads: one thread signals an event and one or more other threads are waiting for it. When I call event.clear() it sets the flag to false. Event.clear() indicates that a barber is busy and no one else can get their haircut at that time. When a barber finishes cutting all the people in the waiting room's hair, he goes to sleep, this triggers the event.wait() which waits until event.set() is called. This allows the program to resume as the barber wakes up.

The only bug I can see is that each barber will go to sleep and they will all wake up if only one customer arrives. I assume only one barber is meant to wake up per customer that enters.